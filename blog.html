<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601355703240458280" data-draft-id="7600755567487156276" data-original-type="0" class="article" data-v-61fb5e44="" data-v-539963b4=""><!----> <meta itemprop="headline" content="前端实现一个高性能的点阵地球-Cobe"> <meta itemprop="keywords" content="前端,CSS,JavaScript"> <meta itemprop="datePublished" content="2026-02-02T00:46:20.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苏武难飞"> <meta itemprop="url" content="https://juejin.cn/user/2664871913328478"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
  前端实现一个高性能的点阵地球-Cobe
  <!----> <!----></h1> <div class="author-info-block" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2664871913328478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
苏武难飞
</span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:46:20.000Z" title="Mon Feb 02 2026 08:46:20 GMT+0800 (中国标准时间)" class="time" data-v-61fb5e44="">
          2026-02-02
        </time>  <span class="views-count" data-v-61fb5e44="">
          524
        </span> <span class="read-time" data-v-61fb5e44="">
          阅读10分钟
        </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <button data-v-b60b2868="" data-v-61fb5e44="" class="jj-follow-button follow"><span data-v-b60b2868="" class="text">关注</span></button></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><div style="height:0;font-size:0;"></div><style>.auditing-placeholder {
width: 100%;
height: 100%;
}
.auditing-placeholder, .loading-placeholder {
pointer-events: none;
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
z-index: 1;
box-sizing: border-box;
overflow: hidden;
border: 0.5px solid rgba(128,128,128,0.4);
border-radius: 8px;
background-color: #18212D;
}
.placeholder-image {
position: absolute;
left: 0;
top: 0;
width: 100%;
height: 100%;
}
.loading-logo {
position: absolute;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
z-index: 1;
width: 171px;
height: 48px;
background-image: repeating-linear-gradient(
94.31deg,
#00cdff 2.29%,
#ffffff 19.72%,
#7d5aff 50%,
#ffffff 85.28%,
#00cdff 97.72%
);
background-size: 200%;
background-repeat: repeat;
clip-path: url(#jcode-logo-clip);
animation: logo-scan 3s linear infinite;
}
@keyframes logo-scan {
0% {
background-position-x: 200%;
}

100% {
background-position-x: 0%;
}
}</style><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">webgl实现一个高性能的点阵地球</h2>
<p>很久没有写博客了，最近依然在学习一些<code>webgl</code>、<code>glsl</code>知识，今天和大家共同学习一个堪称优化到极限的<code>shader</code>代码
<span href="https://code.juejin.cn/pen/7601078756278550568" class="code-editor-container"><iframe class="code-editor-frame" data-code="code-editor-element" data-code-id="7601078756278550568" data-src="https://code.juejin.cn/pen/7601078756278550568" style="display: block;" loading="lazy" src="https://code.juejin.cn/pen/7601078756278550568"></iframe><span class="loading-placeholder" style="display: none;"><img class="placeholder-image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC" loading="lazy"><span class="loading-logo"></span></span></span></p>
<h3 data-id="heading-1">为什么说Cobe堪称极限</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/197f040fdd6c447b9a8d2c6b310c3b5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=p7g13MvExprc8u8A3SFGb%2BHMcwo%3D" alt="Cobe" loading="lazy" class="medium-zoom-image"></p>
<p>首先是<code>Cobe</code>这个库大小只有<code>5KB</code>，并且在移动端上也有非常惊艳的效果，这全部得益于<code>Cobe</code>本身就是基于标准<code>webgl</code>来开发没有使用类似<code>Three.js</code>等大型<code>webgl</code>封装库，以及在<code>shader</code>中利用数学公式来反向推导实现了点阵的效果！没有使用高清纹理图片没有使用<code>cpu</code>来递归循环！</p>
<h3 data-id="heading-2">1.一切从圆开始！</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd5396a81409419398a5e02c6cfa9030~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=bPfhlCI6yCBwABLd1a3o9SY1e3w%3D" alt="20260130141937" loading="lazy" class="medium-zoom-image"></p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"></div><span class="code-block-extension-lang">glsl</span></div><div class="code-block-extension-headerRight"><div data-v-4fdcfe21="" class="code-tips"> <span data-v-4fdcfe21="">体验AI代码助手</span></div><div data-v-159ebe90="" class="render"> <span data-v-159ebe90="" class="txt">代码解读</span></div><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-glsl code-block-extension-codeShowNum" lang="glsl"><span class="code-block-extension-codeLine" data-line-num="1">void main() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">    vec2 uv = gl_FragCoord.xy / u_resolution.xy;</span>
<span class="code-block-extension-codeLine" data-line-num="3">    float aspect = u_resolution.x / u_resolution.y;</span>
<span class="code-block-extension-codeLine" data-line-num="4">    vec2 p = uv * 2. - 1.;</span>
<span class="code-block-extension-codeLine" data-line-num="5">    p.x *= aspect;</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7">    float r = 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="8">    // p.x * p.x + p.y * p.y</span>
<span class="code-block-extension-codeLine" data-line-num="9">    float d2 = dot(p, p);</span>
<span class="code-block-extension-codeLine" data-line-num="10"></span>
<span class="code-block-extension-codeLine" data-line-num="11">    if (d2 &lt; r * r) {</span>
<span class="code-block-extension-codeLine" data-line-num="12">        outColor = vec4(vec3(0.0), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="13">    } else {</span>
<span class="code-block-extension-codeLine" data-line-num="14">        outColor = vec4(vec3(0.141), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="15">    }</span>
<span class="code-block-extension-codeLine" data-line-num="16">}</span>
</code></pre>
<p>根据勾股定理我们知道 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2 + y^2 = r^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，我们利用<code>dot</code>计算出来了<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2 + y^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，然后判断小于半径的我们给一个黑色<code>outColor = vec4(vec3(0.0), 1.0)</code>大于半径的我们给一个背景色<code>outColor = vec4(vec3(0.141), 1.0)</code>，这样就实现了一个半径<code>0.5</code>的圆~</p>
<h3 data-id="heading-3">2.给圆形贴上纹理</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6439d96884484995ad315b206579fbff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=uNFac8XYfw%2FHa9e8olVU5IyWPtI%3D" alt="02" loading="lazy" class="medium-zoom-image"></p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"></div><span class="code-block-extension-lang">glsl</span></div><div class="code-block-extension-headerRight"><div data-v-4fdcfe21="" class="code-tips"> <span data-v-4fdcfe21="">体验AI代码助手</span></div><div data-v-159ebe90="" class="render"> <span data-v-159ebe90="" class="txt">代码解读</span></div><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-glsl code-block-extension-codeShowNum" lang="glsl"><span class="code-block-extension-codeLine" data-line-num="1"></span>
<span class="code-block-extension-codeLine" data-line-num="2">void main() {</span>
<span class="code-block-extension-codeLine" data-line-num="3">    vec2 uv = gl_FragCoord.xy / u_resolution.xy;</span>
<span class="code-block-extension-codeLine" data-line-num="4">    float aspect = u_resolution.x / u_resolution.y;</span>
<span class="code-block-extension-codeLine" data-line-num="5">    vec2 p = uv * 2. - 1.;</span>
<span class="code-block-extension-codeLine" data-line-num="6">    p.x *= aspect;</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8">    float r = 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="9">    // p.x * p.x + p.y * p.y</span>
<span class="code-block-extension-codeLine" data-line-num="10">    float d2 = dot(p, p);</span>
<span class="code-block-extension-codeLine" data-line-num="11"></span>
<span class="code-block-extension-codeLine" data-line-num="12">    if (d2 &lt; r * r) {</span>
<span class="code-block-extension-codeLine" data-line-num="13"></span>
<span class="code-block-extension-codeLine" data-line-num="14">        // 1. 计算球面上该点的法线 (nor)</span>
<span class="code-block-extension-codeLine" data-line-num="15">        // 在正交投影下，z = sqrt(r^2 - x^2 - y^2)</span>
<span class="code-block-extension-codeLine" data-line-num="16">        float z = sqrt(r * r - d2);</span>
<span class="code-block-extension-codeLine" data-line-num="17">        vec3 nor = normalize(vec3(p.x, p.y, z));</span>
<span class="code-block-extension-codeLine" data-line-num="18"></span>
<span class="code-block-extension-codeLine" data-line-num="19">        // 2. 让球转动起来，方便观察两极</span>
<span class="code-block-extension-codeLine" data-line-num="20">        nor = rotateY(u_time * 0.5) * rotateX(u_time * 0.3) * nor;</span>
<span class="code-block-extension-codeLine" data-line-num="21"></span>
<span class="code-block-extension-codeLine" data-line-num="22"></span>
<span class="code-block-extension-codeLine" data-line-num="23">        float u_lon = atan(nor.x, nor.z) / (2.0 * PI) + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="24">        float v_lat = asin(nor.y) / PI + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="25">        float mapValue = texture(u_texture, vec2(u_lon, v_lat)).r;</span>
<span class="code-block-extension-codeLine" data-line-num="26"></span>
<span class="code-block-extension-codeLine" data-line-num="27">        // 5. 颜色输出</span>
<span class="code-block-extension-codeLine" data-line-num="28">        outColor = vec4(vec3(mapValue), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="29"></span>
<span class="code-block-extension-codeLine" data-line-num="30">    } else {</span>
<span class="code-block-extension-codeLine" data-line-num="31">        outColor = vec4(vec3(0.141), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="32">    }</span>
<span class="code-block-extension-codeLine" data-line-num="33">}</span>
<span class="code-block-extension-codeLine" data-line-num="34"></span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c5675e37d3b429ea0454527e0ba5b80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=mkdU4Cna5M9vTCJfL6S0mPIieSU%3D" alt="World_map_blank_without_borders" loading="lazy" class="medium-zoom-image"></p>
<p>我们首先传入一个<code>1280 × 712</code>大小<code>95KB</code>的纹理贴图，然后把我们第一步画好的圆升维到<code>3D</code>的圆，根据<code>3D</code>圆勾股定理<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2 + y^2 + z^2 = r^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，之前我们已经有<code>float d2 = dot(p, p)</code>也就是<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2 + y^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>也知道了<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mn>2</mn></msup><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r^2 = r \cdot r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span>所以<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><msqrt><mrow><msup><mi>r</mi><mn>2</mn></msup><mo>−</mo><msup><mi>d</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">z = \sqrt{r^2 - d^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1266em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9134em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.8734em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1266em;"><span></span></span></span></span></span></span></span></span></span>，现在我们有了<code>x</code>、<code>y</code>、<code>z</code>，就可以归一化之后运用等距柱状投影来把纹理图贴到球体上！</p>
<p>经度映射 (U 坐标)</p>
<ul>
<li>公式推导：使用 atan(x, z) 计算向量在 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">XZ</span></span></span></span></span> 平面（水平面）上的极坐标角度。其范围是 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>π</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-\pi, \pi]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">]</span></span></span></span></span>。</li>
<li>归一化：除以 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>π</mi></mrow><annotation encoding="application/x-tex">2\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span> 后，范围变成 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><mn>0.5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-0.5, 0.5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0.5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0.5</span><span class="mclose">]</span></span></span></span></span>。加上 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn></mrow><annotation encoding="application/x-tex">0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span></span> 后，范围变成 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>。</li>
<li>物理意义：这对应了地球的经度，也就是绕着 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></span> 轴转了一圈。</li>
</ul>
<p>纬度映射</p>
<ul>
<li>(V 坐标)公式推导： asin(y)（反正弦）计算的是向量与 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">XZ</span></span></span></span></span> 平面的夹角。由于是单位圆，其范围是 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mfrac><mi>π</mi><mn>2</mn></mfrac><mo separator="true">,</mo><mfrac><mi>π</mi><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-\frac{\pi}{2}, \frac{\pi}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></span>（即 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>9</mn><msup><mn>0</mn><mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">-90^\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7574em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6741em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span> 到 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><msup><mn>0</mn><mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">90^\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6741em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6741em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span>）。</li>
<li>归一化：除以 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span> 后，范围变成 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><mn>0.5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-0.5, 0.5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0.5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0.5</span><span class="mclose">]</span></span></span></span></span>。加上 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn></mrow><annotation encoding="application/x-tex">0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span></span> 后，范围变成 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>。</li>
<li>物理意义： 这对应了地球的纬度，从南极 (0) 经过赤道 (0.5) 到达北极 (1)。</li>
</ul>
<h3 data-id="heading-4">3.实现一个均分点阵</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b32d8c966efc4d49847bf079e55b2066~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=1W1TeqzX0mh%2F71ws5htO0vIxpBE%3D" alt="03" loading="lazy" class="medium-zoom-image"></p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"></div><span class="code-block-extension-lang">glsl</span></div><div class="code-block-extension-headerRight"><div data-v-4fdcfe21="" class="code-tips"> <span data-v-4fdcfe21="">体验AI代码助手</span></div><div data-v-159ebe90="" class="render"> <span data-v-159ebe90="" class="txt">代码解读</span></div><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-glsl code-block-extension-codeShowNum" lang="glsl"><span class="code-block-extension-codeLine" data-line-num="1">vec2 mappingUV(vec3 nor) {</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3">    // 1. 计算纬度角 theta (从北极 0 到 南极 PI)</span>
<span class="code-block-extension-codeLine" data-line-num="4">    float theta = acos(nor.y);</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6">    // 2. 计算经度角 phi (从 -PI 到 PI)</span>
<span class="code-block-extension-codeLine" data-line-num="7">    float phi = atan(nor.z, nor.x);</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9">    // 3. 将其映射到 [0, 1] 区间以便取索引或上色</span>
<span class="code-block-extension-codeLine" data-line-num="10">    float u = (phi + PI) / (2.0 * PI);</span>
<span class="code-block-extension-codeLine" data-line-num="11">    float v = theta / PI;</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13">    return vec2(u, v);</span>
<span class="code-block-extension-codeLine" data-line-num="14">}</span>
<span class="code-block-extension-codeLine" data-line-num="15"></span>
<span class="code-block-extension-codeLine" data-line-num="16">void main() {</span>
<span class="code-block-extension-codeLine" data-line-num="17">    vec2 uv = gl_FragCoord.xy / u_resolution.xy;</span>
<span class="code-block-extension-codeLine" data-line-num="18">    float aspect = u_resolution.x / u_resolution.y;</span>
<span class="code-block-extension-codeLine" data-line-num="19">    vec2 p = uv * 2. - 1.;</span>
<span class="code-block-extension-codeLine" data-line-num="20">    p.x *= aspect;</span>
<span class="code-block-extension-codeLine" data-line-num="21"></span>
<span class="code-block-extension-codeLine" data-line-num="22">    float r = 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="23">    // p.x * p.x + p.y * p.y</span>
<span class="code-block-extension-codeLine" data-line-num="24">    float d2 = dot(p, p);</span>
<span class="code-block-extension-codeLine" data-line-num="25"></span>
<span class="code-block-extension-codeLine" data-line-num="26">    if (d2 &lt; r * r) {</span>
<span class="code-block-extension-codeLine" data-line-num="27"></span>
<span class="code-block-extension-codeLine" data-line-num="28">        // 1. 计算球面上该点的法线 (nor)</span>
<span class="code-block-extension-codeLine" data-line-num="29">        // 在正交投影下，z = sqrt(r^2 - x^2 - y^2)</span>
<span class="code-block-extension-codeLine" data-line-num="30">        float z = sqrt(r * r - d2);</span>
<span class="code-block-extension-codeLine" data-line-num="31">        vec3 nor = normalize(vec3(p.x, p.y, z));</span>
<span class="code-block-extension-codeLine" data-line-num="32"></span>
<span class="code-block-extension-codeLine" data-line-num="33">        // 2. 让球转动起来，方便观察两极</span>
<span class="code-block-extension-codeLine" data-line-num="34">        nor = rotateY(u_time * 0.5) * rotateX(u_time * 0.3) * nor;</span>
<span class="code-block-extension-codeLine" data-line-num="35"></span>
<span class="code-block-extension-codeLine" data-line-num="36"></span>
<span class="code-block-extension-codeLine" data-line-num="37">//        float u_lon = atan(nor.x, nor.z) / (2.0 * PI) + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="38">//        float v_lat = asin(nor.y) / PI + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="39">//        float mapValue = texture(u_texture, vec2(u_lon, v_lat)).r;</span>
<span class="code-block-extension-codeLine" data-line-num="40"></span>
<span class="code-block-extension-codeLine" data-line-num="41">        // 3. 使用你的 mappingUV 映射到二维</span>
<span class="code-block-extension-codeLine" data-line-num="42">        vec2 st = mappingUV(nor);</span>
<span class="code-block-extension-codeLine" data-line-num="43"></span>
<span class="code-block-extension-codeLine" data-line-num="44">        // 4. 制作点阵</span>
<span class="code-block-extension-codeLine" data-line-num="45">        // st.x 是经度 (0-1)，st.y 是纬度 (0-1)</span>
<span class="code-block-extension-codeLine" data-line-num="46">        // 我们在经度方向分 30 份，纬度方向分 15 份</span>
<span class="code-block-extension-codeLine" data-line-num="47">        vec2 grid = vec2(60.0, 30.0);</span>
<span class="code-block-extension-codeLine" data-line-num="48">        vec2 ipos = floor(st * grid);// 单元格 ID</span>
<span class="code-block-extension-codeLine" data-line-num="49">        vec2 fpos = fract(st * grid);// 单元格内坐标 (0-1)</span>
<span class="code-block-extension-codeLine" data-line-num="50"></span>
<span class="code-block-extension-codeLine" data-line-num="51">        // 在每个格子里画一个圆点</span>
<span class="code-block-extension-codeLine" data-line-num="52">        float dist = distance(fpos, vec2(0.5));</span>
<span class="code-block-extension-codeLine" data-line-num="53">        float dotMask = smoothstep(0.1, 0.09, dist);</span>
<span class="code-block-extension-codeLine" data-line-num="54"></span>
<span class="code-block-extension-codeLine" data-line-num="55"></span>
<span class="code-block-extension-codeLine" data-line-num="56">        // 5. 颜色输出</span>
<span class="code-block-extension-codeLine" data-line-num="57">        outColor = vec4(vec3(dotMask), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="58"></span>
<span class="code-block-extension-codeLine" data-line-num="59">    } else {</span>
<span class="code-block-extension-codeLine" data-line-num="60">        outColor = vec4(vec3(0.141), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="61">    }</span>
<span class="code-block-extension-codeLine" data-line-num="62">}</span>
</code></pre>
<p>这个点阵的实现是根据经纬度均分排列所以我们能看到在南北极的区域点特别密集，在赤道上就会比较稀疏！</p>
<h3 data-id="heading-5">4.实现一个点阵地球</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39f839544caf4e8180d805db64a289dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=H2bjfBHRP9FX2X11v3E0FVyDLQw%3D" alt="04" loading="lazy" class="medium-zoom-image"></p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"></div><span class="code-block-extension-lang">glsl</span></div><div class="code-block-extension-headerRight"><div data-v-4fdcfe21="" class="code-tips"> <span data-v-4fdcfe21="">体验AI代码助手</span></div><div data-v-159ebe90="" class="render"> <span data-v-159ebe90="" class="txt">代码解读</span></div><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-glsl code-block-extension-codeShowNum" lang="glsl"><span class="code-block-extension-codeLine" data-line-num="1">        ...</span>
<span class="code-block-extension-codeLine" data-line-num="2">        ...</span>
<span class="code-block-extension-codeLine" data-line-num="3">        // 3. 使用你的 mappingUV 映射到二维</span>
<span class="code-block-extension-codeLine" data-line-num="4">        vec2 st = mappingUV(nor);</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6">        // 4. 制作点阵</span>
<span class="code-block-extension-codeLine" data-line-num="7">        // st.x 是经度 (0-1)，st.y 是纬度 (0-1)</span>
<span class="code-block-extension-codeLine" data-line-num="8">        // 我们在经度方向分 30 份，纬度方向分 15 份</span>
<span class="code-block-extension-codeLine" data-line-num="9">        vec2 grid = vec2(60.0, 30.0);</span>
<span class="code-block-extension-codeLine" data-line-num="10">        vec2 ipos = floor(st * grid);// 单元格 ID</span>
<span class="code-block-extension-codeLine" data-line-num="11">        vec2 fpos = fract(st * grid);// 单元格内坐标 (0-1)</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13">        // 在每个格子里画一个圆点</span>
<span class="code-block-extension-codeLine" data-line-num="14">        float dist = distance(fpos, vec2(0.5));</span>
<span class="code-block-extension-codeLine" data-line-num="15">        float dotMask = smoothstep(0.1, 0.09, dist);</span>
<span class="code-block-extension-codeLine" data-line-num="16">        float mapValue = texture(u_texture, st).r;</span>
<span class="code-block-extension-codeLine" data-line-num="17"></span>
<span class="code-block-extension-codeLine" data-line-num="18"></span>
<span class="code-block-extension-codeLine" data-line-num="19">        // 5. 颜色输出</span>
<span class="code-block-extension-codeLine" data-line-num="20">        outColor = vec4(vec3(dotMask * mapValue), 1.0);</span>
</code></pre>
<p><code>dotMask * mapValue</code>因为步骤2我们的纹理贴图是<strong>0</strong>或者<strong>1</strong>，步骤3我们的点阵也是<strong>0</strong>或者<strong>1</strong>，所以二者相乘我们就得到了一个最简单的点阵地球！同时大家应该还记得我们用的贴图是一个<code>1280 × 712</code>大小<code>95KB</code>的纹理贴图，但是我们其实只需要纹理中的<strong>0</strong>或者<strong>1</strong>的色值！所以我们替换一张<code>1KB</code>的纹理看看效果！
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccc3f6efeb5f429685a37f95f89897da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=hQZu6NWWw1GWQhxeTB7xA4RfwIE%3D" alt="05" loading="lazy" class="medium-zoom-image"></p>
<p>效果肉眼基本看不出差别！这也是<code>Cobe</code>这个库只有<code>5KB</code>大小的一个核心</p>
<h3 data-id="heading-6">5.斐波那契点阵</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d732c950b40f48ffa68ac81cb0be4f06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=LAAxvxo%2FmpS%2FZgvmsyP61kZwGLA%3D" alt="06" loading="lazy" class="medium-zoom-image"></p>
<p>步骤3的时候我们的点阵方案采用的是经纬度均分，但是步骤3的方案很明显有一个缺点是南极北极的点特别密集集中而赤道的点会相对稀疏，所以我们应该采用<code>斐波那契数列生成的点</code>！关于斐波那契数列有一下资料可以参考</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fobservablehq.com%2F%40mbostock%2Fspherical-fibonacci-lattice" target="_blank" title="https://observablehq.com/@mbostock/spherical-fibonacci-lattice" ref="nofollow noopener noreferrer">Spherical Fibonacci Lattice</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.shadertoy.com%2Fview%2FlllXz4" target="_blank" title="https://www.shadertoy.com/view/lllXz4" ref="nofollow noopener noreferrer">Inverse Spherical Fibonacci </a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F2816795.2818131" target="_blank" title="https://dl.acm.org/doi/10.1145/2816795.2818131" ref="nofollow noopener noreferrer">Spherical fibonacci mapping</a></li>
</ul>
<p>总结一下斐波那契数列的特点</p>
<blockquote>
<p>在 3D 图形学中，要生成这些点，通常使用以下公式：高度（垂直方向）：将球体的高度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> 均匀分成 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span> 份。角度（水平旋转）：每个点相对于上一个点旋转一个黄金角度。黄金角度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>137.</mn><msup><mn>5</mn><mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">\approx 137.5^\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6741em;"></span><span class="mord">137.</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6741em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span>，即 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>π</mi><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2\pi \cdot (1 - \phi^{-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，其中 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></span> 是黄金分割比。这样分布的点，既不会在极点堆积，也不会在赤道稀疏，视觉上极其平衡。</p>
</blockquote>
<p>其实我之前的<a href="https://juejin.cn/post/7440840299759747081" target="_blank" title="https://juejin.cn/post/7440840299759747081">纯CSS实现Soul星球</a>也是对于<code>斐波那契数列</code>的运用，但是我们的目标是在<code>shader</code>中使用，这就涉及到<code>shader</code>的特性了，是同时计算点的位置和颜色而不是通过循环计算生成，但是关于<code>斐波那契数列</code>是没有一个简单的逆向计算公式的！所以这里采用的是<a href="https://link.juejin.cn?target=https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F2816795.2818131" target="_blank" title="https://dl.acm.org/doi/10.1145/2816795.2818131" ref="nofollow noopener noreferrer">Spherical fibonacci mapping</a>提出的计算方法。</p>
<ol>
<li>先估算当前点在整个<code>斐波那契数列</code>中的维度k</li>
<li>计算格网坐标 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span>，也就是<code>斐波那契数列</code>形成的<strong>倾斜网格</strong></li>
<li>小范围遍历（检查格子周围的 4 个点）</li>
</ol>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"></div><span class="code-block-extension-lang">glsl</span></div><div class="code-block-extension-headerRight"><div data-v-4fdcfe21="" class="code-tips"> <span data-v-4fdcfe21="">体验AI代码助手</span></div><div data-v-159ebe90="" class="render"> <span data-v-159ebe90="" class="txt">代码解读</span></div><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-glsl code-block-extension-codeShowNum" lang="glsl"><span class="code-block-extension-codeLine" data-line-num="1">/**</span>
<span class="code-block-extension-codeLine" data-line-num="2"> * 基于斐波那契点阵的快速最近邻搜索</span>
<span class="code-block-extension-codeLine" data-line-num="3"> * p: 输入的球面采样方向（单位向量）</span>
<span class="code-block-extension-codeLine" data-line-num="4"> * m: 输出参数，记录到最近点的距离</span>
<span class="code-block-extension-codeLine" data-line-num="5"> * 返回值: 距离输入点 p 最近的斐波那契点的 3D 坐标</span>
<span class="code-block-extension-codeLine" data-line-num="6"> */</span>
<span class="code-block-extension-codeLine" data-line-num="7">vec3 nearestFibonacciLattice(vec3 p, out float m) {</span>
<span class="code-block-extension-codeLine" data-line-num="8">    // 1. 坐标系转换：将常见的 y-up 转换成 z-up 逻辑进行内部计算</span>
<span class="code-block-extension-codeLine" data-line-num="9">    p = p.xzy;</span>
<span class="code-block-extension-codeLine" data-line-num="10"></span>
<span class="code-block-extension-codeLine" data-line-num="11">    // 2. 自适应层级计算：根据当前点的纬度（p.z）决定搜索密度</span>
<span class="code-block-extension-codeLine" data-line-num="12">    // sqrt5, dots, PI 等常数决定了点阵的总规模</span>
<span class="code-block-extension-codeLine" data-line-num="13">    float k = max(2., floor(log2(sqrt5 * dots * PI * (1. - p.z * p.z)) * byLogPhiPlusOne));</span>
<span class="code-block-extension-codeLine" data-line-num="14"></span>
<span class="code-block-extension-codeLine" data-line-num="15">    // 3. 构造斐波那契网格的基向量 (Basis Vectors)</span>
<span class="code-block-extension-codeLine" data-line-num="16">    // 利用黄金分割比 kPhi 的幂次来定位该层级的格网结构</span>
<span class="code-block-extension-codeLine" data-line-num="17">    vec2 f = floor(pow(kPhi, k)/sqrt5*vec2(1, kPhi)+.5);</span>
<span class="code-block-extension-codeLine" data-line-num="18">    vec2 br1 = fract((f+1.) * phiMinusOne)*kTau - twoPiOnPhi;</span>
<span class="code-block-extension-codeLine" data-line-num="19">    vec2 br2 = -2.*f;</span>
<span class="code-block-extension-codeLine" data-line-num="20">    </span>
<span class="code-block-extension-codeLine" data-line-num="21">    // 4. 将球面坐标转为简单的 2D 极坐标表示 (方位角 theta, 高度 h)</span>
<span class="code-block-extension-codeLine" data-line-num="22">    vec2 sp = vec2(atan(p.y, p.x), p.z-1.);</span>
<span class="code-block-extension-codeLine" data-line-num="23">    </span>
<span class="code-block-extension-codeLine" data-line-num="24">    // 5. 逆矩阵变换：通过矩阵运算，直接推算出目标点在斐波那契网格中的“格子坐标” c</span>
<span class="code-block-extension-codeLine" data-line-num="25">    // 这样就不用遍历几千个点，而是直接锁定目标所在的局部区域</span>
<span class="code-block-extension-codeLine" data-line-num="26">    vec2 c = floor(vec2(br2.y * sp.x - br1.y * (sp.y * dots + 1.), -br2.x * sp.x + br1.x * (sp.y * dots + 1.)) / (br1.x*br2.y-br2.x*br1.y));</span>
<span class="code-block-extension-codeLine" data-line-num="27"></span>
<span class="code-block-extension-codeLine" data-line-num="28">    float mindist = PI; // 初始化最小距离为最大可能值</span>
<span class="code-block-extension-codeLine" data-line-num="29">    vec3 minip;</span>
<span class="code-block-extension-codeLine" data-line-num="30"></span>
<span class="code-block-extension-codeLine" data-line-num="31">    // 6. 局部 4 邻域搜索：检查目标格子周围的 4 个候选点</span>
<span class="code-block-extension-codeLine" data-line-num="32">    for (float s = 0.; s &lt; 4.; s+=1.) {</span>
<span class="code-block-extension-codeLine" data-line-num="33">        vec2 o = vec2(mod(s, 2.), floor(s*.5)); // 生成偏移量 (0,0), (1,0), (0,1), (1,1)</span>
<span class="code-block-extension-codeLine" data-line-num="34">        float idx = dot(f, c + o);            // 根据网格坐标计算出该点的唯一索引 idx</span>
<span class="code-block-extension-codeLine" data-line-num="35">        if (idx &gt; dots) continue;             // 超过总点数则跳过</span>
<span class="code-block-extension-codeLine" data-line-num="36"></span>
<span class="code-block-extension-codeLine" data-line-num="37">        // --- 核心优化：快速计算经度 (Theta) ---</span>
<span class="code-block-extension-codeLine" data-line-num="38">        // 下面这一长串 if 实际上是在对 idx 进行二进制拆解，计算黄金序列的分数值</span>
<span class="code-block-extension-codeLine" data-line-num="39">        // 这是一种为了避免浮点精度丢失而手动实现的快速计算方法</span>
<span class="code-block-extension-codeLine" data-line-num="40">        float tidx = idx;</span>
<span class="code-block-extension-codeLine" data-line-num="41">        float fracV = 0.;</span>
<span class="code-block-extension-codeLine" data-line-num="42"></span>
<span class="code-block-extension-codeLine" data-line-num="43">        ...</span>
<span class="code-block-extension-codeLine" data-line-num="44">        ...</span>
<span class="code-block-extension-codeLine" data-line-num="45"></span>
<span class="code-block-extension-codeLine" data-line-num="46">        float theta = fract(fracV) * kTau; // 最终得到该索引对应的旋转角度</span>
<span class="code-block-extension-codeLine" data-line-num="47"></span>
<span class="code-block-extension-codeLine" data-line-num="48">        // 7. 还原候选点的 3D 坐标</span>
<span class="code-block-extension-codeLine" data-line-num="49">        float cosphi = 1. - 2. * idx * byDots;        // 映射到 Z 轴 [-1, 1]</span>
<span class="code-block-extension-codeLine" data-line-num="50">        float sinphi = sqrt(1. - cosphi * cosphi);    // 根据勾股定理计算水平半径</span>
<span class="code-block-extension-codeLine" data-line-num="51">        vec3 sample2 = vec3(cos(theta) * sinphi, sin(theta) * sinphi, cosphi);</span>
<span class="code-block-extension-codeLine" data-line-num="52"></span>
<span class="code-block-extension-codeLine" data-line-num="53">        // 8. 距离判定</span>
<span class="code-block-extension-codeLine" data-line-num="54">        float dist = length(p - sample2);</span>
<span class="code-block-extension-codeLine" data-line-num="55">        if (dist &lt; mindist) {</span>
<span class="code-block-extension-codeLine" data-line-num="56">            mindist = dist; // 更新最小距离</span>
<span class="code-block-extension-codeLine" data-line-num="57">            minip = sample2; // 记录最近的点</span>
<span class="code-block-extension-codeLine" data-line-num="58">        }</span>
<span class="code-block-extension-codeLine" data-line-num="59">    }</span>
<span class="code-block-extension-codeLine" data-line-num="60"></span>
<span class="code-block-extension-codeLine" data-line-num="61">    m = mindist; // 将距离存入输出变量</span>
<span class="code-block-extension-codeLine" data-line-num="62">    return minip.xzy; // 转回原坐标系方向并返回结果</span>
<span class="code-block-extension-codeLine" data-line-num="63">}</span>
</code></pre>
<p>有了<code>nearestFibonacciLattice</code>方法之后我们就可以替换掉之前的<code>mappingUV</code>方法</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"></div><span class="code-block-extension-lang">glsl</span></div><div class="code-block-extension-headerRight"><div data-v-4fdcfe21="" class="code-tips"> <span data-v-4fdcfe21="">体验AI代码助手</span></div><div data-v-159ebe90="" class="render"> <span data-v-159ebe90="" class="txt">代码解读</span></div><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-glsl code-block-extension-codeShowNum" lang="glsl"><span class="code-block-extension-codeLine" data-line-num="1">void main() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">    vec2 uv = gl_FragCoord.xy / u_resolution.xy;</span>
<span class="code-block-extension-codeLine" data-line-num="3">    float aspect = u_resolution.x / u_resolution.y;</span>
<span class="code-block-extension-codeLine" data-line-num="4">    vec2 p = uv * 2. - 1.;</span>
<span class="code-block-extension-codeLine" data-line-num="5">    p.x *= aspect;</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7">    float r = 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="8">    // p.x * p.x + p.y * p.y</span>
<span class="code-block-extension-codeLine" data-line-num="9">    float d2 = dot(p, p);</span>
<span class="code-block-extension-codeLine" data-line-num="10"></span>
<span class="code-block-extension-codeLine" data-line-num="11">    if (d2 &lt; r * r) {</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13">        // 1. 计算球面上该点的法线 (nor)</span>
<span class="code-block-extension-codeLine" data-line-num="14">        // 在正交投影下，z = sqrt(r^2 - x^2 - y^2)</span>
<span class="code-block-extension-codeLine" data-line-num="15">        float z = sqrt(r * r - d2);</span>
<span class="code-block-extension-codeLine" data-line-num="16">        vec3 nor = normalize(vec3(p.x, p.y, z));</span>
<span class="code-block-extension-codeLine" data-line-num="17"></span>
<span class="code-block-extension-codeLine" data-line-num="18">        // 2. 让球转动起来，方便观察两极</span>
<span class="code-block-extension-codeLine" data-line-num="19">        nor = rotateY(u_time * 0.5) * rotateX(u_time * 0.3) * nor;</span>
<span class="code-block-extension-codeLine" data-line-num="20"></span>
<span class="code-block-extension-codeLine" data-line-num="21"></span>
<span class="code-block-extension-codeLine" data-line-num="22">        // float u_lon = atan(nor.x, nor.z) / (2.0 * PI) + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="23">        // float v_lat = asin(nor.y) / PI + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="24">        // float mapValue = texture(u_texture, vec2(u_lon, v_lat)).r;</span>
<span class="code-block-extension-codeLine" data-line-num="25"></span>
<span class="code-block-extension-codeLine" data-line-num="26">        float dis;</span>
<span class="code-block-extension-codeLine" data-line-num="27">        vec3 gP = nearestFibonacciLattice(nor, dis);</span>
<span class="code-block-extension-codeLine" data-line-num="28"></span>
<span class="code-block-extension-codeLine" data-line-num="29">        float gPhi = asin(gP.y);</span>
<span class="code-block-extension-codeLine" data-line-num="30">        float gTheta = atan(gP.z, gP.x);</span>
<span class="code-block-extension-codeLine" data-line-num="31">        vec2 dotUV = vec2(0.5 + gTheta / kTau, 0.5 + gPhi / PI);</span>
<span class="code-block-extension-codeLine" data-line-num="32">        float isOnLand = step(0.45, texture(u_texture, dotUV).r);</span>
<span class="code-block-extension-codeLine" data-line-num="33"></span>
<span class="code-block-extension-codeLine" data-line-num="34"></span>
<span class="code-block-extension-codeLine" data-line-num="35">        float v = smoothstep(.008, .0, dis);</span>
<span class="code-block-extension-codeLine" data-line-num="36"></span>
<span class="code-block-extension-codeLine" data-line-num="37">        outColor = vec4(vec3(v * isOnLand), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="38"></span>
<span class="code-block-extension-codeLine" data-line-num="39">    } else {</span>
<span class="code-block-extension-codeLine" data-line-num="40">        outColor = vec4(vec3(0.141), 1.0);</span>
<span class="code-block-extension-codeLine" data-line-num="41">    }</span>
<span class="code-block-extension-codeLine" data-line-num="42">}</span>
</code></pre>
<h3 data-id="heading-7">6.优化整体效果</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/befe1b5f24c84fdeaf2695faf505a963~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770597980&amp;x-signature=5gvMHZifa%2F%2FVP8r4XvECwD3Us30%3D" alt="07" loading="lazy" class="medium-zoom-image"></p>
<p>现在我们的点阵已经改为了<code>斐波那契数列</code>实现解决了南极北极点过于密集的问题，但是此时我们还是可以发先球体在旋转的过程边缘的地方还是会产生一些类似摩尔纹的效果，所以我们在边缘的地方实现一下<code>菲涅尔</code>效果，同时添加一下<code>光照</code>计算</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(248, 248, 248);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"></div><span class="code-block-extension-lang">glsl</span></div><div class="code-block-extension-headerRight"><div data-v-4fdcfe21="" class="code-tips"> <span data-v-4fdcfe21="">体验AI代码助手</span></div><div data-v-159ebe90="" class="render"> <span data-v-159ebe90="" class="txt">代码解读</span></div><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-glsl code-block-extension-codeShowNum" lang="glsl"><span class="code-block-extension-codeLine" data-line-num="1">void main() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">    vec2 uv = gl_FragCoord.xy / u_resolution.xy;</span>
<span class="code-block-extension-codeLine" data-line-num="3">    float aspect = u_resolution.x / u_resolution.y;</span>
<span class="code-block-extension-codeLine" data-line-num="4">    vec2 p = uv * 2. - 1.;</span>
<span class="code-block-extension-codeLine" data-line-num="5">    p.x *= aspect;</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7">    float r = 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="8">    // p.x * p.x + p.y * p.y</span>
<span class="code-block-extension-codeLine" data-line-num="9">    float d2 = dot(p, p);</span>
<span class="code-block-extension-codeLine" data-line-num="10"></span>
<span class="code-block-extension-codeLine" data-line-num="11">    float glowFactor = 0.;</span>
<span class="code-block-extension-codeLine" data-line-num="12">    vec4 color = vec4(0);</span>
<span class="code-block-extension-codeLine" data-line-num="13">    float l = dot(p, p);</span>
<span class="code-block-extension-codeLine" data-line-num="14">    float rSquared = r * r;</span>
<span class="code-block-extension-codeLine" data-line-num="15"></span>
<span class="code-block-extension-codeLine" data-line-num="16">    if (d2 &lt; r * r) {</span>
<span class="code-block-extension-codeLine" data-line-num="17"></span>
<span class="code-block-extension-codeLine" data-line-num="18">        // 1. 计算球面上该点的法线 (nor)</span>
<span class="code-block-extension-codeLine" data-line-num="19">        // 在正交投影下，z = sqrt(r^2 - x^2 - y^2)</span>
<span class="code-block-extension-codeLine" data-line-num="20">        float z = sqrt(r * r - d2);</span>
<span class="code-block-extension-codeLine" data-line-num="21">        vec3 nor = normalize(vec3(p.x, p.y, z));</span>
<span class="code-block-extension-codeLine" data-line-num="22">        vec3 rawNor = normalize(vec3(p.x, p.y, z));</span>
<span class="code-block-extension-codeLine" data-line-num="23"></span>
<span class="code-block-extension-codeLine" data-line-num="24">        // 2. 让球转动起来，方便观察两极</span>
<span class="code-block-extension-codeLine" data-line-num="25">        nor = rotateY(u_time * 0.5) * rotateX(u_time * 0.3) * nor;</span>
<span class="code-block-extension-codeLine" data-line-num="26"></span>
<span class="code-block-extension-codeLine" data-line-num="27">        vec4 layer = vec4(0);</span>
<span class="code-block-extension-codeLine" data-line-num="28">        vec3 light = vec3(0, 0, 1);</span>
<span class="code-block-extension-codeLine" data-line-num="29">        float dotNL = dot(rawNor, light);</span>
<span class="code-block-extension-codeLine" data-line-num="30"></span>
<span class="code-block-extension-codeLine" data-line-num="31"></span>
<span class="code-block-extension-codeLine" data-line-num="32">        // float u_lon = atan(nor.x, nor.z) / (2.0 * PI) + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="33">        // float v_lat = asin(nor.y) / PI + 0.5;</span>
<span class="code-block-extension-codeLine" data-line-num="34">        // float mapValue = texture(u_texture, vec2(u_lon, v_lat)).r;</span>
<span class="code-block-extension-codeLine" data-line-num="35"></span>
<span class="code-block-extension-codeLine" data-line-num="36">        float dis;</span>
<span class="code-block-extension-codeLine" data-line-num="37">        vec3 gP = nearestFibonacciLattice(nor, dis);</span>
<span class="code-block-extension-codeLine" data-line-num="38"></span>
<span class="code-block-extension-codeLine" data-line-num="39">        float gPhi = asin(gP.y);</span>
<span class="code-block-extension-codeLine" data-line-num="40">        float gTheta = atan(gP.z, gP.x);</span>
<span class="code-block-extension-codeLine" data-line-num="41">        vec2 dotUV = vec2(0.5 + gTheta / kTau, 0.5 + gPhi / PI);</span>
<span class="code-block-extension-codeLine" data-line-num="42">        float mapColor = step(0.5, texture(u_texture, dotUV).r);</span>
<span class="code-block-extension-codeLine" data-line-num="43">        float v = smoothstep(.008, .0, dis);</span>
<span class="code-block-extension-codeLine" data-line-num="44"></span>
<span class="code-block-extension-codeLine" data-line-num="45"></span>
<span class="code-block-extension-codeLine" data-line-num="46">        float lighting = pow(dotNL, 3.0)*dotsBrightness;</span>
<span class="code-block-extension-codeLine" data-line-num="47">        float sample2 = mapColor * v * lighting;</span>
<span class="code-block-extension-codeLine" data-line-num="48">        float colorFactor = mix((1. - sample2) * pow(dotNL, .4), sample2, dark) + .1;</span>
<span class="code-block-extension-codeLine" data-line-num="49">        layer += vec4(baseColor * colorFactor, 1.);</span>
<span class="code-block-extension-codeLine" data-line-num="50"></span>
<span class="code-block-extension-codeLine" data-line-num="51"></span>
<span class="code-block-extension-codeLine" data-line-num="52">        layer.xyz += pow(1. - dotNL, 4.) * glowColor;</span>
<span class="code-block-extension-codeLine" data-line-num="53"></span>
<span class="code-block-extension-codeLine" data-line-num="54">        color += layer * (1. + opacity) * .5;</span>
<span class="code-block-extension-codeLine" data-line-num="55"></span>
<span class="code-block-extension-codeLine" data-line-num="56">        glowFactor = pow(dot(normalize(vec3(-uv, sqrt(1.- l))), vec3(0, 0, 1)), 4.) * smoothstep(0., 1., .2/(l-rSquared));</span>
<span class="code-block-extension-codeLine" data-line-num="57">        </span>
<span class="code-block-extension-codeLine" data-line-num="58"></span>
<span class="code-block-extension-codeLine" data-line-num="59">    } else {</span>
<span class="code-block-extension-codeLine" data-line-num="60">        float outD = sqrt(.2/(l - rSquared));</span>
<span class="code-block-extension-codeLine" data-line-num="61">        glowFactor = smoothstep(0.5, 1., outD / (outD + 1.));</span>
<span class="code-block-extension-codeLine" data-line-num="62">    }</span>
<span class="code-block-extension-codeLine" data-line-num="63">    outColor = color + vec4(glowFactor * glowColor, glowFactor);</span>
<span class="code-block-extension-codeLine" data-line-num="64">}</span>
</code></pre>
<p>光照的核心部分就是计算点阵的颜色以及基础色和最后的扩散的颜色~</p>
<h3 data-id="heading-8">结束语</h3>
<p>最近有些懒惰了，更新博客也不勤快了！希望2026年能坚持下去</p>
<h3 data-id="heading-9">参考资料</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fshuding%2Fcobe" target="_blank" title="https://github.com/shuding/cobe" ref="nofollow noopener noreferrer">Cobe</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fobservablehq.com%2F%40mbostock%2Fspherical-fibonacci-lattice" target="_blank" title="https://observablehq.com/@mbostock/spherical-fibonacci-lattice" ref="nofollow noopener noreferrer">Spherical Fibonacci Lattice</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.shadertoy.com%2Fview%2FlllXz4" target="_blank" title="https://www.shadertoy.com/view/lllXz4" ref="nofollow noopener noreferrer">Inverse Spherical Fibonacci </a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F2816795.2818131" target="_blank" title="https://dl.acm.org/doi/10.1145/2816795.2818131" ref="nofollow noopener noreferrer">Spherical fibonacci mapping</a></li>
</ul></div></div></article>